/**
 * MQTT Service
 * Broker and client for IoT communication
 *
 * Generated by AGL
 */

import Aedes from 'aedes';
import { createServer, Server } from 'net';
import { connect, MqttClient } from 'mqtt';
import { IoTMonitoringController } from '@/controllers';

/**
 * Minimal MQTT service: start/stop broker, publish messages and perform
 * a request-response (publish then wait for correlated response).
 */
export class MqttService {
  private aedes: Aedes;
  private server: Server;
  private client: MqttClient | null = null;
  private port: number;
  private isRunning: boolean = false;
  private clientId: string;
  private iotMonitoring : IoTMonitoringController = new IoTMonitoringController();

  constructor(port: number = 1883, clientId: string = 'flashclip-backend-internal') {
    this.port = port;
    this.clientId = clientId;
    this.aedes = new Aedes();
    this.server = createServer(this.aedes.handle);
  }

  public async start(): Promise<void> {
    if (this.isRunning) return;
    return new Promise((resolve, reject) => {
      this.server.listen(this.port, (err?: Error) => {
        if (err) return reject(err);
        this.isRunning = true;
        // create internal client to publish
        this.client = connect(`mqtt://0.0.0.0:${this.port}`, {
          clientId: this.clientId,
          clean: true,
        });

        this.client.on('connect', () => {
          console.log('[MQTT] internal client connected');
        });

        this.client.on('message', (topic, message) => {
          if (topic.endsWith('/info')) {
            // save info to database
            const deviceName = topic.split('/')[1];
            const info = message.toString();
            console.log(`[MQTT] Info from device ${deviceName}: ${info}`);

            this.iotMonitoring.saveAgentInfo(deviceName, JSON.parse(info)).catch((e) => {
              console.error(
                `[MQTT] Failed to save agent info for device ${deviceName}:`,
                e
              );
            });
          }
        });

        this.client.on('error', (e) =>
          console.error('[MQTT] internal client error', e)
        );
        resolve();
      });
    });
  }

  public async stop(): Promise<void> {
    if (!this.isRunning) return;
    return new Promise((resolve) => {
      if (this.client) {
        try {
          this.client.end(true);
        } catch {}
        this.client = null;
      }
      this.server.close(() => {
        try {
          this.aedes.close(() => {});
        } catch {}
        this.isRunning = false;
        resolve();
      });
    });
  }

  public async publish(
    topic: string,
    message: string | object,
    options: { qos?: 0 | 1 | 2; retain?: boolean } = {}
  ): Promise<void> {
    if (!this.client) throw new Error('MQTT internal client not available');
    const payload =
      typeof message === 'string' ? message : JSON.stringify(message);
    return new Promise((resolve, reject) => {
      this.client!.publish(
        topic,
        payload,
        { qos: options.qos ?? 0, retain: options.retain ?? false },
        (err?: Error) => {
          if (err) return reject(err);
          resolve();
        }
      );
    });
  }

  public subscribe(
    topic: string,
    callback: (topic: string, message: Buffer) => void,
    options: { qos?: 0 | 1 | 2 } = {}
  ): void {
    if (!this.client) throw new Error('MQTT internal client not available');
    this.client.subscribe(topic, { qos: options.qos ?? 1 }, (err) => {
      if (err) {
        console.error(`[MQTT] Failed to subscribe to topic ${topic}:`, err);
      } else {
        console.log(`[MQTT] Subscribed to topic ${topic}`);
      }
    });
    this.client.on('message', callback);
  }

  public get running(): boolean {
    return this.isRunning;
  }

  public get brokerPort(): number {
    return this.port;
  }
}

export const mqttService = new MqttService();
