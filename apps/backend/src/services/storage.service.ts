/**
 * Storage Service
 * Handles file upload, download, and management
 * 
 * Generated by AGL
 */

import { CustomAdapter } from './storage/custom.adapter';
import { validateFile } from './storage/upload.utils';

export interface UploadOptions {
  folder?: string;
  fileName?: string;
  metadata?: Record<string, string>;
}

export interface FileMetadata {
  path: string;
  url: string;
  size: number;
  mimeType: string;
  uploadedAt: Date;
}

export interface DirectoryEntry {
  href: string;
  sz?: number;
  ext?: string;
  ts?: number;
  lead?: string;
}

export interface FileEntry {
  href: string;
  sz?: number;
  ext?: string;
  ts?: number;
  mime?: string;
  lead?: string;
}

export interface ListResponse {
  dirs: DirectoryEntry[];
  files: FileEntry[];
  [key: string]: unknown;
}

export interface ListOptions {
  includeDots?: boolean;
}

export class StorageService {
  private static instance: StorageService;
  private adapter: CustomAdapter;

  private constructor() {
        this.adapter = new CustomAdapter();
      }

  static getInstance(): StorageService {
    if (!StorageService.instance) {
      StorageService.instance = new StorageService();
    }
    return StorageService.instance;
  }

  /**
   * Upload a file to storage
   */
  async upload(
    file: File | Blob,
    options?: UploadOptions
  ): Promise<FileMetadata> {
    // Validate file
    validateFile(file, {
      allowedTypes: [],
      maxSizeMB: 10,
    });

    // Generate path based on structure
    const path = this.generatePath(file, options);

    // Upload using adapter
    const result = await this.adapter.upload(file, path, options);

    return result;
  }


  /**
   * Download a file from storage
   */
  async download(path: string): Promise<Buffer> {
    return this.adapter.download(path);
  }

  /**
   * Delete a file from storage
   */
  async delete(path: string): Promise<void> {
    return this.adapter.delete(path);
  }

  /**
   * Get public URL for a file
   */
  async getUrl(path: string): Promise<string> {
    return this.adapter.getUrl(path);
  }

  /**
   * List files and folders at a path (custom provider only)
   */
  async list(path: string, options?: ListOptions): Promise<ListResponse> {
    // Adapter may throw when unsupported (e.g., S3)
    return (this.adapter as any).list(path, options);
  }

  async getStorageInfo(): Promise<{
    used: number;
    limit: number;
  }> {
    // List all files and sum sizes
    let used = 0;
    const listAllFiles = async (path: string) => {
      console.log('Listing path:', path);
      const list = await this.list(path);
      for (const file of list.files) {
        if (file.sz) {
          used += file.sz;
        }
      }
      for (const dir of list.dirs) {
        await listAllFiles(`${path}${dir.href}`);
      }
    };

    await listAllFiles('/');
    
    // For this example, assume a fixed limit (e.g., 20 GB)
    const limit = 20 * 1024 * 1024 * 1024;
    return { used, limit };
  }

  /**
   * Generate file path based on structure configuration
   */
  private generatePath(file: File | Blob, options?: UploadOptions): string {
    const parts: string[] = [];

    
    
    // Add custom folder if provided
    if (options?.folder) {
      parts.push(options.folder);
    }

    // Add filename
    const fileName = options?.fileName || this.generateFileName(file);
    parts.push(fileName);

    return parts.join('/');
  }

  private generateFileName(file: File | Blob): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const ext = (file as any).name?.split('.').pop() || 'bin';
    return `${timestamp}-${random}.${ext}`;
  }
}

// Export singleton instance
export const storage = StorageService.getInstance();
