/**
 * Storage Service
 * Handles file upload, download, and management
 * 
 * Generated by AGL
 */

import { validateFile } from './storage/upload.utils';
import { CustomAdapter } from './storage/custom.adapter';

export interface UploadOptions {
  folder?: string;
  fileName?: string;
  metadata?: Record<string, string>;
}

export interface FileMetadata {
  path: string;
  url: string;
  size: number;
  mimeType: string;
  uploadedAt: Date;
}

export interface DirectoryEntry {
  href: string;
  sz?: number;
  ext?: string;
  ts?: number;
  lead?: string;
}

export interface FileEntry {
  href: string;
  sz?: number;
  ext?: string;
  ts?: number;
  mime?: string;
  lead?: string;
}

export interface ListResponse {
  dirs: DirectoryEntry[];
  files: FileEntry[];
  [key: string]: unknown;
}

export interface ListOptions {
  includeDots?: boolean;
}

export class StorageService {
  private static instance: StorageService;
  private adapter: CustomAdapter;

  private constructor() {
        this.adapter = new CustomAdapter();
      }

  static getInstance(): StorageService {
    if (!StorageService.instance) {
      StorageService.instance = new StorageService();
    }
    return StorageService.instance;
  }

  /**
   * Upload a file to storage
   */
  async upload(
    file: File | Blob,
    options?: UploadOptions
  ): Promise<FileMetadata> {
    // Validate file
    validateFile(file, {
      allowedTypes: [],
      maxSizeMB: 10,
    });

    // Generate path based on structure
    const path = this.generatePath(file, options);

    // Upload using adapter
    const result = await this.adapter.upload(file, path, options);

    return result;
  }


  /**
   * Download a file from storage
   */
  async download(path: string): Promise<Buffer> {
    return this.adapter.download(path);
  }

  /**
   * Delete a file from storage
   */
  async delete(path: string): Promise<void> {
    return this.adapter.delete(path);
  }

  /**
   * Get public URL for a file
   */
  async getUrl(path: string): Promise<string> {
    return this.adapter.getUrl(path);
  }

  /**
   * List files and folders at a path (custom provider only)
   */
  async list(path: string, options?: ListOptions): Promise<ListResponse> {
    // Adapter may throw when unsupported (e.g., S3)
    return (this.adapter as any).list(path, options);
  }

  /**
   * Get storage info (used space and limit)
   */
  async getStorageInfo(): Promise<{ used: number; limit: number }> {
    try {
      // Get all videos to calculate total storage
      const listResult = await this.list('upload', { includeDots: false });
      
      let totalSize = 0;
      
      // Calculate size from all files
      const calculateDirSize = async (dirPath: string): Promise<number> => {
        const result = await this.list(dirPath, { includeDots: false });
        let size = 0;
        
        // Add file sizes
        for (const file of result.files) {
          size += file.sz || 0;
        }
        
        // Recursively calculate subdirectories
        for (const dir of result.dirs) {
          const subPath = dir.href.replace(/\/$/, '');
          size += await calculateDirSize(subPath);
        }
        
        return size;
      };
      
      totalSize = await calculateDirSize('upload');
      
      // Storage limit: 100 GB
      const storageLimit = 107374182400; // 100 GB in bytes
      
      return {
        used: totalSize,
        limit: storageLimit
      };
    } catch (error) {
      console.error('Error getting storage info:', error);
      // Return default values if there's an error
      return {
        used: 0,
        limit: 107374182400 // 100 GB
      };
    }
  }

  /**
   * Generate file path based on structure configuration
   */
  private generatePath(file: File | Blob, options?: UploadOptions): string {
    const parts: string[] = [];

    
    
    // Add custom folder if provided
    if (options?.folder) {
      parts.push(options.folder);
    }

    // Add filename
    const fileName = options?.fileName || this.generateFileName(file);
    parts.push(fileName);

    return parts.join('/');
  }

  private generateFileName(file: File | Blob): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const ext = (file as any).name?.split('.').pop() || 'bin';
    return `${timestamp}-${random}.${ext}`;
  }
}

// Export singleton instance
export const storage = StorageService.getInstance();
