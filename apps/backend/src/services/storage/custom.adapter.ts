/**
 * Custom Storage Adapter
 * Connects to your custom file server
 * 
 * Generated by AGL - TODO: Implement according to your file server's API
 */

import type {
  FileMetadata,
  ListOptions,
  ListResponse,
  UploadOptions,
} from '../storage.service';

export class CustomAdapter {
  private baseUrl: string;
  private password?: string;
  private useQueryAuth: boolean;

  constructor() {
    this.baseUrl = (process.env.FILE_SERVER_URL || 'https://files.server.begue.cc/flashclip').replace(/\/+$/, '');
    this.password =
      process.env.FILE_SERVER_PASSWORD ||
      process.env.FILE_SERVER_PW ||
      process.env.FILE_SERVER_TOKEN ||
      '';
    this.useQueryAuth = true;
  }

  /**
   * Upload a file using the server's PUT API (binary body, optional JSON response via `want=json`).
   */
  async upload(
    file: File | Blob,
    path: string,
    options?: UploadOptions
  ): Promise<FileMetadata> {
    void options;
    const buffer = Buffer.from(await file.arrayBuffer());
    const uploadUrl = this.buildUrl(path, { want: 'json' });

    const response = await fetch(uploadUrl.toString(), {
      method: 'PUT',
      headers: this.getAuthHeaders({
        'Content-Type': (file as any).type || 'application/octet-stream',
        Accept: 'application/json',
      }),
      body: buffer,
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => response.statusText);
      throw new Error(`Upload failed (${response.status}): ${errorText}`);
    }

    const payload = await this.parseJsonSafe(response);
    const mimeType = (file as any).type || payload?.mimeType || payload?.mime || 'application/octet-stream';
    const uploadedAt = payload?.uploadedAt ? new Date(payload.uploadedAt) : new Date();

    return {
      path: payload?.path || path,
      url: payload?.url || this.buildUrl(path).toString(),
      size: (file as any).size ?? buffer.byteLength,
      mimeType,
      uploadedAt,
    };
  }

  /**
   * Download a file via `GET ?dl` to avoid inline rendering.
   */
  async download(path: string): Promise<Buffer> {
    const url = this.buildUrl(path, { dl: '' });
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: this.getAuthHeaders(),
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => response.statusText);
      throw new Error(`Download failed (${response.status}): ${errorText}`);
    }

    return Buffer.from(await response.arrayBuffer());
  }

  /**
   * Delete a file/folder using the `POST ?delete` endpoint.
   */
  async delete(path: string): Promise<void> {
    const url = this.buildUrl(path, { delete: '' });
    const response = await fetch(url.toString(), {
      method: 'POST',
      headers: this.getAuthHeaders(),
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => response.statusText);
      throw new Error(`Delete failed (${response.status}): ${errorText}`);
    }
  }

  /**
   * Return a direct URL; includes `pw` when configured for query auth.
   */
  async getUrl(path: string): Promise<string> {
    return this.buildUrl(path).toString();
  }

  /**
   * List files and folders via `GET ?ls` (optionally including dotfiles).
   */
  async list(path: string, options?: ListOptions): Promise<ListResponse> {
    const params: Record<string, string | boolean> = { ls: '' };
    if (options?.includeDots) {
      params.dots = '';
    }

    const url = this.buildUrl(path, params);
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: this.getAuthHeaders({ Accept: 'application/json' }),
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => response.statusText);
      throw new Error(`List failed (${response.status}): ${errorText}`);
    }

    const payload = await this.parseJsonSafe(response);
    if (!payload) {
      throw new Error('List failed: empty response');
    }

    return {
      dirs: Array.isArray(payload.dirs) ? payload.dirs : [],
      files: Array.isArray(payload.files) ? payload.files : [],
      ...payload,
    } as ListResponse;
  }

  private buildUrl(path: string, params?: Record<string, string | number | boolean | undefined>): URL {
    const cleanPath = path.replace(/^\/+/, '');
    const base = this.baseUrl.endsWith('/') ? this.baseUrl : `${this.baseUrl}/`;
    const url = new URL(cleanPath, base);

    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value === undefined || value === false) continue;
        if (value === true || value === '') {
          url.searchParams.set(key, '');
        } else {
          url.searchParams.set(key, String(value));
        }
      }
    }

    if (this.useQueryAuth && this.password) {
      url.searchParams.set('pw', this.password);
    }

    return url;
  }

  private getAuthHeaders(additional?: Record<string, string>): Record<string, string> {
    const headers: Record<string, string> = { ...(additional || {}) };

    if (this.password) {
      headers['Cookie'] = `cppwd=${this.password}`;
      headers['pw'] = this.password;
    }

    return headers;
  }

  private async parseJsonSafe(response: Response): Promise<any | undefined> {
    const contentType = response.headers.get('content-type') || '';

    if (contentType.includes('application/json') || contentType.includes('text/json')) {
      return response.json();
    }

    const text = await response.text().catch(() => undefined);
    try {
      return text ? JSON.parse(text) : undefined;
    } catch (error) {
      console.warn('Upload response was not JSON:', error);
      return undefined;
    }
  }
}
