/**
 * Custom Storage Adapter
 * Connects to your custom file server
 * 
 * Generated by AGL - TODO: Implement according to your file server's API
 */

import type { FileMetadata, UploadOptions } from '../storage.service';

export class CustomAdapter {
  private baseUrl: string;
  private authToken?: string;

  constructor() {
    this.baseUrl = process.env.FILE_SERVER_URL || 'https://files.server.begue.cc/flashclip';
      }

  /**
   * Upload a file to your custom server
   * TODO: Implement according to your API specification
   */
  async upload(
    file: File | Blob,
    path: string,
    options?: UploadOptions
  ): Promise<FileMetadata> {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('path', path);
    if (options?.metadata) {
      formData.append('metadata', JSON.stringify(options.metadata));
    }

    try {
      const response = await fetch(`${this.baseUrl}/upload`, {
        method: 'POST',
        headers: this.getHeaders(),
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.statusText}`);
      }

      const result = await response.json();
      
      // TODO: Map your API response to FileMetadata
      return {
        path: result.path || path,
        url: result.url || `${this.baseUrl}/files/${path}`,
        size: (file as any).size || 0,
        mimeType: (file as any).type || 'application/octet-stream',
        uploadedAt: new Date(result.uploadedAt || new Date()),
      };
    } catch (error) {
      console.error('Custom server upload failed:', error);
      throw new Error(`Failed to upload file: ${(error as Error).message}`);
    }
  }

  /**
   * Download a file from your custom server
   * TODO: Implement according to your API
   */
  async download(path: string): Promise<Buffer> {
    try {
      const response = await fetch(`${this.baseUrl}/download/${path}`, {
        headers: this.getHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Download failed: ${response.statusText}`);
      }

      return Buffer.from(await response.arrayBuffer());
    } catch (error) {
      console.error('Custom server download failed:', error);
      throw new Error(`Failed to download file: ${(error as Error).message}`);
    }
  }

  /**
   * Delete a file from your custom server
   * TODO: Implement according to your API
   */
  async delete(path: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/delete/${path}`, {
        method: 'DELETE',
        headers: this.getHeaders(),
      });

      if (!response.ok) {
        throw new Error(`Delete failed: ${response.statusText}`);
      }
    } catch (error) {
      console.error('Custom server delete failed:', error);
      throw new Error(`Failed to delete file: ${(error as Error).message}`);
    }
  }

  /**
   * Get public URL for a file
   * TODO: Implement according to your API
   */
  async getUrl(path: string): Promise<string> {
    return `${this.baseUrl}/files/${path}`;
  }

  private getHeaders(): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    if (this.authToken) {
      headers['Authorization'] = `Bearer ${this.authToken}`;
    }

    return headers;
  }
}
