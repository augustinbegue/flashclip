/**
 * VideoManagementController * Business logic for videomanagement feature
 * 
 * Generated by AGL
 */

// Domain types from spec
import { db } from '@/services/database.service';
import { storage } from '@/services/storage.service';
import type { AIVideos, Video, VideoResponse } from '@repo/types';

const RAW_VIDEO_ROOT = "upload/demo-rpi/";
const AI_VIDEO_ROOT = "videos/demo-rpi/";
const AI_VARIANTS = ["emoji.mp4", "engaging.mp4", "subtitles.mp4"] as const;

export class VideoManagementController {
  /**
   * Controller methods for videomanagement feature
   */

  /**
   * listVideos   */
  async listVideos(): Promise<Video[]> {
    try {
      const listResponse = await storage.list(RAW_VIDEO_ROOT);
      const videoFiles = (listResponse.files || []).filter((file) =>
        this.isVideo(file.href),
      );

      const videos = (
        await Promise.all(
          videoFiles.map(async (file) => {
            const fileName = this.extractFileName(file.href);
            if (!fileName) return null;

            const url = await storage.getUrl(`${RAW_VIDEO_ROOT}${fileName}`);
            const record = await this.ensureVideoRecord(fileName, url);
            return record;
          }),
        )
      ).filter(Boolean) as Video[];

      return videos;
    } catch (error) {
      console.error("Error in listVideos:", error);
      throw error;
    }
  }

  /**
   * filterVideos   */
  async filterVideos(params: {
    query?: string | undefined;
  }): Promise<Video[]> {
    try {
      const query = params.query?.trim().toLowerCase();
      const videos = await this.listVideos();

      const filtered = query
        ? videos.filter((video) => {
            const haystack =
              `${video.id} ${video.title} ${video.description}`.toLowerCase();
            return haystack.includes(query);
          })
        : videos;

      return filtered;
    } catch (error) {
      console.error("Error in filterVideos:", error);
      throw error;
    }
  }

  /**
   * getVideoDetails   */
  async getVideoDetails(params: { videoId?: string }): Promise<VideoResponse> {
    try {
      const videoId = params.videoId?.trim();
      if (!videoId) {
        throw new Error("videoId is required");
      }

      const url = await storage.getUrl(`${RAW_VIDEO_ROOT}${videoId}.mp4`);
      const video = await this.ensureVideoRecord(videoId, url);
      const aiResults = await this.buildAIResults(videoId);

      return { ...video, aiResults };
    } catch (error) {
      console.error("Error in getVideoDetails:", error);
      throw error;
    }
  }

  /**
   * getAIResults - Récupère uniquement les URLs des vidéos générées par IA
   */
  async getAIResults(params: { videoId?: string }): Promise<{ data: AIVideos }> {
    try {
      const videoId = params.videoId?.trim();
      if (!videoId) {
        throw new Error("videoId is required");
      }

      const aiResults = await this.buildAIResults(videoId);

      return { data: aiResults };
    } catch (error) {
      console.error("Error in getAIResults:", error);
      throw error;
    }
  }

  /**
   * getAIVideo - Récupère l'URL d'une variante spécifique de vidéo IA
   */
  async getAIVideo(params: { videoId?: string; variant?: string }): Promise<{ data: { url: string } }> {
    try {
      const videoId = params.videoId?.trim();
      const variant = params.variant?.trim().toLowerCase();

      if (!videoId) {
        throw new Error("videoId is required");
      }

      if (!variant) {
        throw new Error("variant is required");
      }

      const validVariants = ["original", "emoji", "engaging", "subtitles"];
      if (!validVariants.includes(variant)) {
        throw new Error(`Invalid variant. Must be one of: ${validVariants.join(", ")}`);
      }

      const baseVideoId = videoId.replace(/\.mp4$/, "");
      let url: string;

      if (variant === "original") {
        url = await storage.getUrl(`${RAW_VIDEO_ROOT}${baseVideoId}.mp4`);
      } else {
        url = await storage.getUrl(`${RAW_VIDEO_ROOT}${baseVideoId}_${variant}.mp4`);
      }

      return { data: { url } };
    } catch (error) {
      console.error("Error in getAIVideo:", error);
      throw error;
    }
  }

  private isVideo(href?: string): boolean {
    return typeof href === "string" && href.toLowerCase().endsWith(".mp4");
  }

  private extractFileName(href?: string): string | null {
    if (!href) return null;
    const parts = href.split("/");
    const name = parts[parts.length - 1];
    return name || null;
  }

  private toTitle(fileName: string): string {
    const base = fileName.replace(/\.[^.]+$/, "");
    const pretty = base.replace(/[-_]+/g, " ").trim();
    return pretty || base || fileName;
  }

  private async ensureVideoRecord(
    videoId: string,
    url: string,
  ): Promise<Video> {
    let id = videoId.replace(/\.[^.]+$/, "");
    const existing = await db.video.findUnique({ where: { id } });
    if (existing) {
      if (existing.url !== url) {
        return db.video.update({ where: { id }, data: { url } });
      }
      return existing;
    }

    return db.video.create({
      data: {
        id,
        title: this.toTitle(videoId),
        description: "",
        url,
        duration: 0,
        userId: "system",
      },
    });
  }

  private async buildAIResults(videoId: string): Promise<AIVideos> {
    // Remove .mp4 extension if present
    const baseVideoId = videoId.replace(/\.mp4$/, "");

    const results: AIVideos = {
      emoji: "",
      engaging: "",
      subtitles: "",
      original: "",
    };

    // Generate URLs for AI variants in the format: {videoId}_emoji.mp4
    // All variants are in the same folder as the original (upload/demo-rpi/)
    for (const variant of AI_VARIANTS) {
      const key = variant.replace(".mp4", "") as keyof AIVideos;
      try {
        // Format: upload/demo-rpi/{videoId}_emoji.mp4
        const path = `${RAW_VIDEO_ROOT}${baseVideoId}_${key}.mp4`;
        results[key] = await storage.getUrl(path);
      } catch (error) {
        results[key] = "";
      }
    }

    // Original video URL
    results.original = await storage.getUrl(`${RAW_VIDEO_ROOT}${baseVideoId}.mp4`);

    return results;
  }
}
