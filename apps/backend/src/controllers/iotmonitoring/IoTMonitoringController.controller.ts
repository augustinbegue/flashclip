/**
 * IoTMonitoringController * Business logic for iotmonitoring feature
 * 
 * Generated by AGL
 */

// Domain types from spec
import { DatabaseService } from '@/services/database.service';
import { mqttService } from '@/services/mqtt.service';
import type { IoTDevice } from '@repo/types';

function generateId(): string {
  return `${Date.now()}-${Math.floor(Math.random() * 100000)}`;
}

export interface AgentInfoStatus extends IoTDevice {
  versionTimestamp: number;
}

type AgentInfoPayload = {
  device_id: string;
  event: string;
  timestamp?: number;
  info?: {
    hostname?: string;
    version?: {
      version?: string;
      versionTs?: number;
    };
  };
};
export class IoTMonitoringController {
  private db = DatabaseService.getInstance();
  
  /**
   * Controller methods for iotmonitoring feature
   */

  /**
   * listDevices   */
  async listDevices(): Promise<IoTDevice> {
    try {
      // TODO: Implement listDevices      // This method should:
      // 1. Validate input parameters
      // 2. Call appropriate services
      // 3. Transform and return data
      
      throw new Error('Not implemented');
    } catch (error) {
      console.error('Error in listDevices:', error);
      throw error;
    }
  }

  /**
   * refreshDeviceStatus   */
  async refreshDeviceStatus(deviceId: string): Promise<AgentInfoStatus | null> {
    try {
      const agentInfo = await this.db.agentInfo.findUnique({
        where: { deviceId },
      });

      if (!agentInfo) {
        return null;
      }

      // Convert BigInt to Number for JSON serialization
      return {
        ...agentInfo,
        versionTimestamp: Number(agentInfo.versionTimestamp)
      };
    } catch (error) {
      console.error('Error in refreshDeviceStatus:', error);
      throw error;
    }
  }

  /**
   * Start record remotly
   */
  async startRecord(deviceId: string): Promise<{ ok : boolean; id?: string }> {
    try {
      const id = generateId();
      const payload = {
        type: 'start_record',
        data: {},
        id,
      };
      await mqttService.publish(`flashclip/${deviceId}/commands`, payload, {
        qos: 1,
      });

      return { ok: true, id };
    } catch (error) {
      console.error('Error in startRecord:', error);
      throw { ok: false };
    }
  }

  /**
   * Save Agent Info
   */
  async saveAgentInfo(
    deviceId: string,
    info: AgentInfoPayload
  ) {
    // Use timestamp from payload or current time
    const timestamp = info.timestamp || Date.now();
    
    // Extract versionTimestamp and convert to BigInt if present
    let versionTimestamp: bigint = BigInt(timestamp);
    if (info?.info?.version?.versionTs) {
      versionTimestamp = BigInt(info.info.version.versionTs);
    }

    // Build info object with defaults
    const infoData = {
      device_id: info.device_id,
      event: info.event,
      timestamp,
      info: {
        hostname: info.info?.hostname || 'unknown',
        version: {
          version: info.info?.version?.version || '0.0.0',
          versionTs: info.info?.version?.versionTs || timestamp,
        },
      },
    };

    const agentInfo = await this.db.agentInfo.upsert({
      where: { deviceId },
      update: {
        info: infoData,
        versionTimestamp,
      },
      create: {
        deviceId,
        info: infoData,
        versionTimestamp,
      },
    });

    return agentInfo;
  };
}
